import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.HashMap;
import java.util.LinkedHashMap;

/* FILES */
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.charset.StandardCharsets;


/**
 * Escrever num ficheiro do tipo .g4 as produções da gramática.
 */		
public class Generator 
{
	private static void joinLogic(StringBuilder members, RoseTree node) {
		for (Map.Entry<String, String> entry : node.getAttributes().entrySet()) {
			String attribute = entry.getKey();
			String value = entry.getValue();
			
			String variable = 
				node.getPath() + node.getValue() + "__" + attribute.toUpperCase();
			
			/* Junção variáveis em @members. */
			members.append("\tfinal String " + variable + " = \"" + value + "\";\n");
		}
	}

	private static void generateProductions(Map<String, StringBuilder> productions, StringBuilder members, RoseTree node, StringBuilder phrase) {
		String component = node.getValue();

		boolean hasOtherProduction = false;
		StringBuilder prod = productions.get(component);
		if (prod == null) {
			prod = new StringBuilder("");

			productions.put(component, prod);
		} else {
			hasOtherProduction = true;
		}

		List<RoseTree> children = node.getChildren();	
		
		if (children.isEmpty()) {
			List<String> lexical_part = node.getLexicalPart();
			
			if (!lexical_part.isEmpty()) {
				String word = lexical_part.get(0);

				phrase.append(word);
				phrase.append(' ');

				// Acrescentar parte léxica à produção.	
				if (prod.toString().equals(""))
					prod.append("'" + word + "'");
				else
					prod.append(" | '" + word + "'");
			}
		} else {
			for (RoseTree child : children) {
				if (!child.getValue().equals(""))
					if (child.getRequiredState())
						if (hasOtherProduction)
							prod.append("| " + child.getValue().toLowerCase() + " ");
						else
							prod.append(child.getValue().toLowerCase() + " ");
					else
						if (hasOtherProduction)
							prod.append("| (" + child.getValue().toLowerCase() + ")? ");
						else 
							prod.append("(" + child.getValue().toLowerCase() + ")? ");

				generateProductions(productions, members, child, phrase);
			}
		}	

		joinLogic(members, node);
	}
	
	public static void generateGrammar(List<RoseTree> struct, List<String> error_conditions) {
		/* Initialize phrase StringBuilder. */
		StringBuilder phrase = new StringBuilder();

		/* Estrutura auxiliar que guardará as produções ao longo da árvore. */
		Map<String, StringBuilder> productions = new HashMap<>(); 
		
		/* Linhas a serem escritas no ficheiro final. */
		List<String> lines = 
			new ArrayList<>(Arrays.asList("/* GENERATED BY Meta_Grammar.g4 */\n", "grammar Grammar;\n"));

		StringBuilder members = new StringBuilder("@members {\n");

		StringBuilder main_prod = new StringBuilder("main :");
		
		for (int i = 0; i < struct.size(); i++) {
			RoseTree node = struct.get(i);
			
			if (!node.getValue().equals("")) {
				main_prod.append(" " + node.getValue().toLowerCase());
				generateProductions(productions, members, node, phrase);
			}
		}

		members.append("}\n\n");	

		lines.add(members.toString());
	
		// Injetar condições de erro.
		main_prod.append("\n{\n");
		for (String err : error_conditions) {
			main_prod.append("\t" + err + "\n");
		}
		main_prod.append("}\n;\n");

		lines.add(main_prod.toString());
		
		/* Escrever as produções completas. */
		for (Map.Entry<String, StringBuilder> entry : productions.entrySet()) {
			String component = entry.getKey();
			StringBuilder prod = entry.getValue();
			
			if (!component.equals("")) {	
				StringBuilder full_prod = new StringBuilder("");

				if (prod.toString().equals("")) {
					full_prod.append(component.toLowerCase() + " : \n;\n");
				} else {
					full_prod.append(component.toLowerCase() + " : " + prod.toString() + "\n;\n");
				}
				
				lines.add(full_prod.toString());
			}
		}
		
		/* Write LEXER */
		List<String> lexer = Arrays
			.asList(
				"\n\n/* LEXER */\n",
				"WORD : (CHAR)+ \n;\n",
				"WS : ([ \\t\\r\\n]|COMMENT) -> skip \n;\n",
				"fragment CHAR : [a-zA-ZáéíóúÁÉÍÓÚâêîôûÂÊÎÔÛãõÃÕàèìòùÀÈÌÒÙçÇ_] \n;\n",
				"fragment COMMENT : '/*'.*?'*/' | '//'~('\\r'|'\\n')* \n;\n" 
			);

		lines.addAll(lexer);

        try {
			// Se o ficheiro não existe, criar e depois escrever.
			// Se o ficheiro existe, truncar (remover todo o conteúdo) e escrever.
            Files.write(Paths.get("./Grammar.g4"), lines, StandardCharsets.UTF_8);
			
			// Write temporary input phrase.
			Files.write(Paths.get("./phrase.tmp"), phrase.toString().getBytes());
        } catch (IOException e) {
            System.err.format("IOException: %s%n", e);
        }
	}
}
